Desctiption: fix compilation of api_demos
Author: Christophe Trophime <christophe.trophime@lncmi.cnrs.fr>
Reviewed-by: Anton Gladky <gladky.anton@gmail.com>
Last-Update: 2012-03-11

--- a/utils/api_demos/CMakeLists.txt
+++ b/utils/api_demos/CMakeLists.txt
@@ -9,45 +9,691 @@
   set(CMAKE_BUILD_TYPE RelWithDebInfo CACHE STRING "Choose build type")
 endif(DEFINED CMAKE_BUILD_TYPE)
 
-project(api_demos CXX)
+project(api_demos CXX C)
 
-add_subdirectory(../.. "${CMAKE_CURRENT_BINARY_DIR}/gmsh")
-
-include_directories(../../Common ../../Numeric ../../Geo ../../Mesh 
-   ../../Solver ../../Post ../../Plugin ../../Graphics ../../contrib/ANN/include
-   ../../contrib/DiscreteIntegration ${GMSH_EXTERNAL_INCLUDE_DIRS}
-   ${CMAKE_CURRENT_BINARY_DIR}/gmsh/Common)
+# this variable controls the default value of the "ENABLE_XXX" options which are
+# normally set to ON (useful if you want to configure a minimal version of Gmsh:
+# e.g. "cmake -DDEFAULT=0 -DENABLE_POST=1 -DENABLE_PARSER=1")
+set(DEFAULT ON CACHE INTERNAL "Default value for options")
+
+option(ENABLE_GMSH "Enable Gmsh" ${DEFAULT})
+option(ENABLE_ANN "Enable ANN to compute Approximate Nearest Neighbors" ${DEFAULT})
+option(ENABLE_KBIPACK "Enable Kbipack for homology solver" ${DEFAULT})
+option(ENABLE_MATHEX "Enable MathEx expression parser" ${DEFAULT})
+option(ENABLE_OCC "Enable Open CASCADE geometrical models" ${DEFAULT})
+option(ENABLE_PETSC "Enable PETSc linear algebra solvers" ${DEFAULT})
+option(ENABLE_SLEPC "Enable SLEPc eigensolvers" ${DEFAULT})
+option(ENABLE_FLTK "Build FLTK GUI" ${DEFAULT})
+option(ENABLE_FL_TREE "Enable FLTK tree browser widget" ${DEFAULT})
+option(ENABLE_MED "Enable MED mesh and post-processing file formats" ${DEFAULT})
+option(ENABLE_MMG3D "Enable 3D Mobile Mesh Generation" ${DEFAULT})
+option(ENABLE_TETGEN "Enable Tetgen mesh generator" ${DEFAULT})
+option(ENABLE_TETGEN_NEW "Enable experimental version of Tetgen" OFF)
+option(ENABLE_GRAPHICS "Compile-in OpenGL graphics even if there is no GUI" OFF)
+option(ENABLE_MESH "Build the mesh module" ${DEFAULT})
+option(ENABLE_POST "Build the post-processing module" ${DEFAULT})
+option(ENABLE_PLUGINS "Build the post-processing plugins" ${DEFAULT})
+option(ENABLE_DINTEGRATION "Enable discrete integration and levelsets" ${DEFAULT})
+option(ENABLE_BLAS_LAPACK "Use BLAS and Lapack for linear algebra" ON)
+
+include(CheckTypeSize)
+include(CheckFunctionExists)
+include(CheckIncludeFile)
+
+macro(find_all_libraries VARNAME LISTNAME PATH SUFFIX)
+  set(${VARNAME})
+  list(LENGTH ${LISTNAME} NUM_LIST)
+  foreach(LIB ${${LISTNAME}})
+    find_library(FOUND_LIB ${LIB} PATHS ${PATH} PATH_SUFFIXES ${SUFFIX})
+    if(FOUND_LIB)
+      list(APPEND ${VARNAME} ${FOUND_LIB})
+    endif(FOUND_LIB)
+    set(FOUND_LIB FOUND_LIB-NOTFOUND CACHE INTERNAL "")
+    # unset(FOUND_LIB CACHE) # cleaner, but only available in cmake >= 2.6.4
+  endforeach(LIB)
+  list(LENGTH ${VARNAME} NUM_FOUND_LIBRARIES)
+  if(NUM_FOUND_LIBRARIES LESS NUM_LIST)
+    set(${VARNAME})
+  endif(NUM_FOUND_LIBRARIES LESS NUM_LIST)
+endmacro(find_all_libraries)
+
+macro(set_config_option VARNAME STRING)
+  set(${VARNAME} TRUE)
+  list(APPEND CONFIG_OPTIONS ${STRING})
+  message(STATUS "Found " ${STRING})
+endmacro(set_config_option)
+
+# check if the machine is 64 bits (this is more reliable than using
+# CMAKE_SIZEOF_VOID_P, which does not seem to work e.g. on some Suse
+# machines)
+check_type_size("void*" SIZEOF_VOID_P)
+if(SIZEOF_VOID_P EQUAL 8)
+  set_config_option(HAVE_64BIT_SIZE_T "Have64BitSizeT")
+endif(SIZEOF_VOID_P EQUAL 8)
+
+if(ENABLE_BLAS_LAPACK)
+  if(MSVC)
+    # on Windows with Visual C++ try really hard to find blas/lapack
+    # *without* requiring a Fortran compiler: 1) try to find the Intel
+    # MKL libs using the standard search path; if not found 2) try to
+    # get the reference blas/lapack libs (useful for users with no
+    # Fortran compiler and no MKL license, who can just download our
+    # precompiled "gmsh-dep" package)
+    if(HAVE_64BIT_SIZE_T)
+      set(MKL_PATH em64t/lib)
+    else(HAVE_64BIT_SIZE_T)
+      set(MKL_PATH ia32/lib)
+    endif(HAVE_64BIT_SIZE_T)
+    set(MKL_LIBS_REQUIRED libguide40 mkl_intel_c mkl_intel_thread mkl_core)
+    find_all_libraries(LAPACK_LIBRARIES MKL_LIBS_REQUIRED "" ${MKL_PATH})
+    if(LAPACK_LIBRARIES)
+      set_config_option(HAVE_BLAS "Blas(IntelMKL)")
+      set_config_option(HAVE_LAPACK "Lapack(IntelMKL)")
+    else(LAPACK_LIBRARIES)
+      set(REFLAPACK_LIBS_REQUIRED lapack blas g2c gcc)
+      find_all_libraries(LAPACK_LIBRARIES REFLAPACK_LIBS_REQUIRED "" "")
+      if(LAPACK_LIBRARIES)
+        set_config_option(HAVE_BLAS "Blas(Ref)")
+        set_config_option(HAVE_LAPACK "Lapack(Ref)")
+      endif(LAPACK_LIBRARIES)
+    endif(LAPACK_LIBRARIES)
+  elseif(${CMAKE_SYSTEM_NAME} MATCHES "Linux")
+    # on Linux try to find the Intel MKL without a Fortran compiler
+    if(HAVE_64BIT_SIZE_T)
+      set(MKL_PATH lib/em64t)
+    else(HAVE_64BIT_SIZE_T)
+      set(MKL_PATH lib/32)
+    endif(HAVE_64BIT_SIZE_T)
+    set(MKL_LIBS_REQUIRED mkl_gf_lp64 iomp5 mkl_gnu_thread mkl_core guide pthread)
+    find_all_libraries(LAPACK_LIBRARIES MKL_LIBS_REQUIRED "" ${MKL_PATH})
+    if(NOT LAPACK_LIBRARIES)
+      #match lapack 9.0 on 64bit
+      set(MKL_LIBS_REQUIRED mkl_lapack mkl_em64t guide)
+      find_all_libraries(LAPACK_LIBRARIES MKL_LIBS_REQUIRED "" ${MKL_PATH})
+    endif(NOT LAPACK_LIBRARIES)
+    if(LAPACK_LIBRARIES)
+      set_config_option(HAVE_BLAS "Blas(IntelMKL)")
+      set_config_option(HAVE_LAPACK "Lapack(IntelMKL)")
+    else(LAPACK_LIBRARIES)
+      # on Linux also try to find ATLAS without a Fortran compiler,
+      # because cmake ships with a buggy FindBLAS e.g. on Ubuntu Lucid
+      # Lynx
+      set(ATLAS_LIBS_REQUIRED lapack f77blas cblas atlas)
+      find_all_libraries(LAPACK_LIBRARIES ATLAS_LIBS_REQUIRED "" "")
+      if(LAPACK_LIBRARIES)
+        set_config_option(HAVE_BLAS "Blas(ATLAS)")
+        set_config_option(HAVE_LAPACK "Lapack(ATLAS)")
+      endif(LAPACK_LIBRARIES)
+    endif(LAPACK_LIBRARIES)
+  elseif(${CMAKE_SYSTEM_NAME} MATCHES "SunOS")
+    # on SunOS we know blas and lapack are available in sunperf
+    set(LAPACK_FLAGS -library=sunperf)
+    set_config_option(HAVE_BLAS "Blas(SubPerf)")
+    set_config_option(HAVE_LAPACK "Lapack(SunPerf)")
+  elseif(APPLE)
+    # on Mac we also know that blas and lapack are available
+    set(LAPACK_LIBRARIES "-framework vecLib")
+    set_config_option(HAVE_BLAS "Blas(VecLib)")
+    set_config_option(HAVE_LAPACK "Lapack(VecLib)")
+  endif(MSVC)
+  if(NOT HAVE_BLAS OR NOT HAVE_LAPACK)
+    # if we haven't found blas and lapack without using the standard
+    # cmake tests, do it (this requires a working Fortran compiler)
+    enable_language(Fortran)
+    find_package(BLAS)
+    if(BLAS_FOUND)
+      set_config_option(HAVE_BLAS "Blas")
+      find_package(LAPACK)
+      if(LAPACK_FOUND)
+        set_config_option(HAVE_LAPACK "Lapack")
+      else(LAPACK_FOUND)
+        set(LAPACK_LIBRARIES ${BLAS_LIBRARIES})
+      endif(LAPACK_FOUND)
+      if(CMAKE_Fortran_COMPILER_ID MATCHES "GNU")
+        if(CMAKE_Fortran_COMPILER MATCHES "gfortran")
+          list(APPEND LAPACK_LIBRARIES gfortran)
+        elseif(CMAKE_Fortran_COMPILER MATCHES "f95")
+          list(APPEND LAPACK_LIBRARIES gfortran)
+        elseif(CMAKE_Fortran_COMPILER MATCHES "g77")
+          list(APPEND LAPACK_LIBRARIES g2c)
+        endif(CMAKE_Fortran_COMPILER MATCHES "gfortran")
+      endif(CMAKE_Fortran_COMPILER_ID MATCHES "GNU")
+    endif(BLAS_FOUND)
+  endif(NOT HAVE_BLAS OR NOT HAVE_LAPACK)
+  if(NOT HAVE_BLAS OR NOT HAVE_LAPACK)
+    message("WARNING: Could not find Blas or Lapack: most meshing algorithms "
+            "will not be functional")
+  endif(NOT HAVE_BLAS OR NOT HAVE_LAPACK)
+endif(ENABLE_BLAS_LAPACK)
+
+if(ENABLE_KBIPACK)
+  find_library(GMP_LIB gmp)
+  if(GMP_LIB)
+    find_path(GMP_INC "gmp.h" PATH_SUFFIXES src include)
+    if(GMP_INC)
+      set_config_option(HAVE_GMP "GMP")
+      list(APPEND EXTERNAL_LIBRARIES ${GMP_LIB})
+      list(APPEND EXTERNAL_INCLUDES ${GMP_INC})
+      include_directories(../../contrib/kbipack)
+      set_config_option(HAVE_KBIPACK "Kbipack")
+    endif(GMP_INC)
+  endif(GMP_LIB)
+endif(ENABLE_KBIPACK)
+
+if(ENABLE_MATHEX)
+  include_directories(../../contrib/MathEx)
+  set_config_option(HAVE_MATHEX "MathEx")
+endif(ENABLE_MATHEX)
+
+if(ENABLE_PETSC)
+    set(ENV_PETSC_DIR $ENV{PETSC_DIR})
+    set(ENV_PETSC_ARCH $ENV{PETSC_ARCH})
+    if(EXISTS ${ENV_PETSC_DIR}/${ENV_PETSC_ARCH}/conf/petscvariables)
+      # old-style PETSc installations (using PETSC_DIR and PETSC_ARCH)
+      set_config_option(HAVE_PETSC "PETSc")
+      file(STRINGS ${ENV_PETSC_DIR}/${ENV_PETSC_ARCH}/conf/petscvariables 
+           PETSC_VARIABLES NEWLINE_CONSUME)
+      # find include directories
+      list(APPEND EXTERNAL_INCLUDES ${ENV_PETSC_DIR}/include)
+      list(APPEND EXTERNAL_INCLUDES ${ENV_PETSC_DIR}/${ENV_PETSC_ARCH}/include)
+      string(REGEX MATCH "PACKAGES_INCLUDES = [^\n\r]*" PETSC_PACKAGES_INCLUDES
+             ${PETSC_VARIABLES})
+      if(PETSC_PACKAGES_INCLUDES)
+        string(REPLACE "PACKAGES_INCLUDES = " "" PETSC_PACKAGES_INCLUDES
+               ${PETSC_PACKAGES_INCLUDES})
+        if(PETSC_PACKAGES_INCLUDES)
+          string(REPLACE "-I" "" PETSC_PACKAGES_INCLUDES ${PETSC_PACKAGES_INCLUDES})
+          string(REPLACE " " ";" PETSC_PACKAGES_INCLUDES ${PETSC_PACKAGES_INCLUDES})
+          foreach(VAR ${PETSC_PACKAGES_INCLUDES})
+            list(APPEND EXTERNAL_INCLUDES ${VAR})
+          endforeach(VAR)
+        endif(PETSC_PACKAGES_INCLUDES)
+      endif(PETSC_PACKAGES_INCLUDES)
+      # find libraries (<= 3.0)
+      set(PETSC_LIBS_REQUIRED petscksp petscdm petscmat petscvec petsc)
+      find_all_libraries(PETSC_LIBS PETSC_LIBS_REQUIRED 
+                         ${ENV_PETSC_DIR}/${ENV_PETSC_ARCH}/lib "")
+      # petsc 3.1 creates only one library (libpetsc)
+      if(NOT PETSC_LIBS)
+        find_library(PETSC_LIBS petsc PATHS ${ENV_PETSC_DIR}/${ENV_PETSC_ARCH}/lib)
+      endif(NOT PETSC_LIBS)
+      # find slepc (needs to be linked in before petsc)
+      if(ENABLE_SLEPC)
+        set(ENV_SLEPC_DIR $ENV{SLEPC_DIR})
+        find_library(SLEPC_LIB slepc PATHS ${ENV_SLEPC_DIR}/${ENV_PETSC_ARCH}/lib)
+        if(SLEPC_LIB)
+          find_path(SLEPC_INC "slepc.h" PATHS ${ENV_SLEPC_DIR} PATH_SUFFIXES include 
+                    ${ENV_PETSC_ARCH}/include include/slepc)
+          if(SLEPC_INC)
+            set_config_option(HAVE_SLEPC "SLEPc")
+            list(APPEND EXTERNAL_LIBRARIES ${SLEPC_LIB})
+            list(APPEND EXTERNAL_INCLUDES ${SLEPC_INC}) 
+            find_path(SLEPC_INC2 "slepcconf.h" PATHS ${ENV_SLEPC_DIR} 
+                      PATH_SUFFIXES ${ENV_PETSC_ARCH}/include)
+            if(SLEPC_INC2)
+              list(APPEND EXTERNAL_INCLUDES ${SLEPC_INC2}) 
+            endif(SLEPC_INC2)
+          endif(SLEPC_INC)
+        endif(SLEPC_LIB)
+        if(NOT HAVE_SLEPC AND NOT ENV_SLEPC_DIR)
+           message("WARNING: Export SLEPC_DIR before calling cmake")
+        endif(NOT HAVE_SLEPC AND NOT ENV_SLEPC_DIR)
+      endif(ENABLE_SLEPC)
+      list(APPEND EXTERNAL_LIBRARIES ${PETSC_LIBS})
+      # find additional libraries to link with
+      string(REGEX MATCH "PACKAGES_LIBS = [^\n\r]*" PLIBS ${PETSC_VARIABLES})
+      if(PLIBS)
+        string(REPLACE "PACKAGES_LIBS = " "" PLIBS ${PLIBS})
+        string(STRIP ${PLIBS} PLIBS)
+        list(APPEND EXTERNAL_LIBRARIES "${PLIBS}")
+      endif(PLIBS)
+      string(REGEX MATCH "PETSC_EXTERNAL_LIB_BASIC = [^\n\r]*" PLIBS_BASIC ${PETSC_VARIABLES})
+      if(PLIBS_BASIC)
+        string(REPLACE "PETSC_EXTERNAL_LIB_BASIC = " "" PLIBS_BASIC ${PLIBS_BASIC})
+        string(STRIP ${PLIBS_BASIC} PLIBS_BASIC)
+        list(APPEND EXTERNAL_LIBRARIES "${PLIBS_BASIC}")
+      endif(PLIBS_BASIC)
+      string(REGEX MATCH "PCC_LINKER_LIBS = [^\n\r]*" LLIBS ${PETSC_VARIABLES})
+      if(LLIBS)
+        string(REPLACE "PCC_LINKER_LIBS = " "" LLIBS ${LLIBS})
+        string(STRIP ${LLIBS} LLIBS)
+        list(APPEND EXTERNAL_LIBRARIES "${LLIBS}")
+      endif(LLIBS)
+    else(EXISTS ${ENV_PETSC_DIR}/${ENV_PETSC_ARCH}/conf/petscvariables)
+      # new-style PETSc installations (in standard system directories)
+      find_library(PETSC_LIBS petsc)
+      find_path(PETSC_INC "petsc.h" PATH_SUFFIXES include/petsc)
+      if(PETSC_LIBS AND PETSC_INC)
+        set_config_option(HAVE_PETSC "PETSc")
+        if(ENABLE_SLEPC)
+          find_library(SLEPC_LIB slepc)
+          find_path(SLEPC_INC "slepc.h" PATH_SUFFIXES include/slepc)
+          if(SLEPC_LIB AND SLEPC_INC)
+            set_config_option(HAVE_SLEPC "SLEPc")
+            list(APPEND EXTERNAL_LIBRARIES ${SLEPC_LIB})
+            list(APPEND EXTERNAL_INCLUDES ${SLEPC_INC}) 
+          endif(SLEPC_LIB AND SLEPC_INC)
+        endif(ENABLE_SLEPC)
+        list(APPEND EXTERNAL_LIBRARIES ${PETSC_LIBS})
+        list(APPEND EXTERNAL_INCLUDES ${PETSC_INC}) 
+      endif(PETSC_LIBS AND PETSC_INC)
+    endif(EXISTS ${ENV_PETSC_DIR}/${ENV_PETSC_ARCH}/conf/petscvariables)
+    if(NOT HAVE_PETSC AND NOT ENV_PETSC_DIR)
+       message("WARNING: Export PETSC_DIR before calling cmake")
+    endif(NOT HAVE_PETSC AND NOT ENV_PETSC_DIR)
+    if(NOT HAVE_PETSC AND NOT ENV_PETSC_ARCH)
+       message("WARNING: Export PETSC_ARCH before calling cmake")
+    endif(NOT HAVE_PETSC AND NOT ENV_PETSC_ARCH)
+  endif(ENABLE_PETSC)
+
+if(ENABLE_OCC)
+  if(WIN32 OR CYGWIN)
+    if(HAVE_64BIT_SIZE_T)
+      set(OCC_SYS_NAME win64)
+    else(HAVE_64BIT_SIZE_T)
+      set(OCC_SYS_NAME win32)
+    endif(HAVE_64BIT_SIZE_T)
+  else(WIN32 OR CYGWIN)
+    set(OCC_SYS_NAME ${CMAKE_SYSTEM_NAME})
+  endif(WIN32 OR CYGWIN)
+  set(OCC_LIBS_REQUIRED
+      # subset of DataExchange
+      TKSTEP TKSTEP209 TKSTEPAttr TKSTEPBase TKIGES TKXSBase
+      # ModelingAlgorithms
+      TKOffset TKFeat TKFillet TKBool TKShHealing TKMesh TKHLR TKBO TKPrim
+      TKTopAlgo TKGeomAlgo
+      # ModelingData
+      TKBRep TKGeomBase TKG3d TKG2d
+      # FoundationClasses
+      TKAdvTools TKMath TKernel)
+  list(LENGTH OCC_LIBS_REQUIRED NUM_OCC_LIBS_REQUIRED)
+  set(OCC_LIBS)
+  foreach(OCC ${OCC_LIBS_REQUIRED})
+    find_library(OCC_LIB ${OCC} HINTS ENV CASROOT PATH_SUFFIXES lib 
+                 ${OCC_SYS_NAME}/lib ${OCC_SYS_NAME}/vc8/lib)
+    if(OCC_LIB)
+      list(APPEND OCC_LIBS ${OCC_LIB})
+    else(OCC_LIB)
+      message(STATUS "OCC lib " ${OCC} " not Found")
+    endif(OCC_LIB)
+    set(OCC_LIB OCC_LIB-NOTFOUND CACHE INTERNAL "")
+    # unset(OCC_LIB CACHE) # cleaner, but only available in cmake >= 2.6.4
+  endforeach(OCC)
+  list(LENGTH OCC_LIBS NUM_OCC_LIBS)
+  if(NUM_OCC_LIBS EQUAL NUM_OCC_LIBS_REQUIRED)
+    find_path(OCC_INC "BRep_Tool.hxx" PATHS ENV CASROOT PATH_SUFFIXES inc 
+              include include/oce opencascade)
+    if(OCC_INC)
+      set_config_option(HAVE_OCC "OpenCascade")
+      list(APPEND EXTERNAL_LIBRARIES ${OCC_LIBS})
+      list(APPEND EXTERNAL_INCLUDES ${OCC_INC})
+      if(HAVE_64BIT_SIZE_T)
+        add_definitions(-D_OCC64)
+      endif(HAVE_64BIT_SIZE_T)
+      if(CYGWIN)
+        list(APPEND EXTERNAL_LIBRARIES "winspool")
+      elseif(MSVC)
+        add_definitions(-DWNT)
+      endif(CYGWIN)
+      find_path(OCC_CONFIG_H "config.h" PATHS ${OCC_INC} ${OCC_CONFIG_H_PATH}
+                NO_DEFAULT_PATH)
+      if(NOT OCC_CONFIG_H)
+        add_definitions(-DHAVE_NO_OCC_CONFIG_H)
+      endif(NOT OCC_CONFIG_H)
+    endif(OCC_INC)
+  endif(NUM_OCC_LIBS EQUAL NUM_OCC_LIBS_REQUIRED)
+endif(ENABLE_OCC)
+
+if(ENABLE_ANN)
+  find_library(ANN_LIB ann PATH_SUFFIXES lib)
+  find_path(ANN_INC "ANN.h" PATH_SUFFIXES src include ANN)
+  if(ANN_LIB AND ANN_INC)
+    list(APPEND EXTERNAL_LIBRARIES ${ANN_LIB})
+    list(APPEND EXTERNAL_INCLUDES ${ANN_INC})
+    set_config_option(HAVE_ANN "Ann")
+  else(ANN_LIB AND ANN_INC)
+    message(STATUS "System ANN not found - using contrib/ANN instead")
+    add_subdirectory(../contrib/ANN)
+    include_directories(../contrib/ANN/include)
+  endif(ANN_LIB AND ANN_INC)
+endif(ENABLE_ANN)
+
+find_library(GMSH_LIB gmsh PATH_SUFFIXES lib)
+find_path(GMSH_INC "Gmsh.h" PATH_SUFFIXES src include gmsh)
+if(GMSH_LIB AND GMSH_INC)
+  list(APPEND EXTERNAL_LIBRARIES ${GMSH_LIB})
+  list(APPEND EXTERNAL_INCLUDES ${GMSH_INC})
+  set_config_option(HAVE_GMSH "Gmsh")
+else(GMSH_LIB AND GMSH_INC)
+  message(STATUS "Gmsh.h not found")
+endif(GMSH_LIB AND GMSH_INC)
+
+find_library(ANTTWEAKBAR_LIB AntTweakBar PATH_SUFFIXES lib)
+find_path(ANTTWEAKBAR_INC "AntTweakBar.h" PATH_SUFFIXES src include AntTweakBar)
+if(ANTTWEAKBAR_LIB AND ANTTWEAKBAR_INC)
+  list(APPEND EXTERNAL_LIBRARIES ${ANTTWEAKBAR_LIB})
+  list(APPEND EXTERNAL_INCLUDES ${ANTTWEAKBAR_INC})
+  set_config_option(HAVE_ANTTWEAKBAR "AntTweakBar")
+else(ANTTWEAKBAR_LIB AND ANTTWEAKBAR_INC)
+  message(STATUS "ANTTWEAKBAR not found")
+endif(ANTTWEAKBAR_LIB AND ANTTWEAKBAR_INC)
+
+if(ENABLE_FLTK)
+  # first, try to use fltk-config for fltk >= 1.3 (FindFLTK is buggy
+  # on Unix, where e.g. xft and xinerama options are not dealt with)
+  find_program(FLTK_CONFIG_SCRIPT fltk-config)
+  if(FLTK_CONFIG_SCRIPT)
+    execute_process(COMMAND ${FLTK_CONFIG_SCRIPT} --api-version
+                    OUTPUT_VARIABLE FLTK_VERSION)
+    string(STRIP ${FLTK_VERSION} FLTK_VERSION)
+    if(FLTK_VERSION GREATER 1.1)
+      set_config_option(HAVE_FLTK "Fltk")
+      message(STATUS "Using fltk-config script for Fltk " ${FLTK_VERSION})
+      execute_process(COMMAND ${FLTK_CONFIG_SCRIPT} --use-gl --use-images --includedir
+                      OUTPUT_VARIABLE FLTK_INCLUDE_DIR)
+      string(STRIP ${FLTK_INCLUDE_DIR} FLTK_INCLUDE_DIR)
+      list(APPEND EXTERNAL_INCLUDES ${FLTK_INCLUDE_DIR} ${FLTK_INCLUDE_DIR}/FL/images
+           ${FLTK_INCLUDE_DIR}/jpeg ${FLTK_INCLUDE_DIR}/zlib ${FLTK_INCLUDE_DIR}/png)
+      execute_process(COMMAND ${FLTK_CONFIG_SCRIPT} --use-gl --use-images --ldflags
+                      OUTPUT_VARIABLE FLTK_LIBRARIES)
+      string(STRIP ${FLTK_LIBRARIES} FLTK_LIBRARIES)
+      string(REGEX MATCH "fltk[_ ]jpeg" FLTK_JPEG ${FLTK_LIBRARIES})
+      string(REGEX MATCH "fltk[_ ]z" FLTK_Z ${FLTK_LIBRARIES})
+      string(REGEX MATCH "fltk[_ ]png" FLTK_PNG ${FLTK_LIBRARIES})
+    endif(FLTK_VERSION GREATER 1.1)
+  endif(FLTK_CONFIG_SCRIPT)
+  # then try the built-in FindFLTK module
+  if(NOT HAVE_FLTK)
+    set(FLTK_SKIP_FORMS TRUE)
+    set(FLTK_SKIP_FLUID TRUE)
+    find_package(FLTK)
+    if(FLTK_FOUND)
+      add_subdirectory(Fltk)
+      set_config_option(HAVE_FLTK "Fltk")
+      list(APPEND EXTERNAL_INCLUDES ${FLTK_INCLUDE_DIR})
+      # find fltk jpeg
+      find_library(FLTK_JPEG NAMES fltk_jpeg fltkjpeg)
+      if(FLTK_JPEG)
+        list(APPEND EXTERNAL_LIBRARIES ${FLTK_JPEG})
+        foreach(DIR ${FLTK_INCLUDE_DIR})
+          list(APPEND EXTERNAL_INCLUDES ${DIR}/FL/images ${DIR}/jpeg)
+        endforeach(DIR)
+      endif(FLTK_JPEG)
+      # find fltk zlib
+      find_library(FLTK_Z NAMES fltk_z fltkz)
+      if(FLTK_Z)
+        list(APPEND EXTERNAL_LIBRARIES ${FLTK_Z})
+        foreach(DIR ${FLTK_INCLUDE_DIR})
+          list(APPEND EXTERNAL_INCLUDES ${DIR}/FL/images ${DIR}/zlib)
+        endforeach(DIR)
+      endif(FLTK_Z)
+      # find fltk png
+      find_library(FLTK_PNG NAMES fltk_png fltkpng)
+      if(FLTK_PNG)
+        list(APPEND EXTERNAL_LIBRARIES ${FLTK_PNG})
+        foreach(DIR ${FLTK_INCLUDE_DIR})
+          list(APPEND EXTERNAL_INCLUDES ${DIR}/FL/images ${DIR}/png)
+        endforeach(DIR)
+      endif(FLTK_PNG)   
+    endif(FLTK_FOUND)
+  endif(NOT HAVE_FLTK)
+  if(HAVE_FLTK)
+    if(ENABLE_NATIVE_FILE_CHOOSER)
+      if(NOT FLTK_VERSION OR FLTK_VERSION EQUAL 1.1)
+        add_subdirectory(contrib/NativeFileChooser)
+        include_directories(contrib/NativeFileChooser)
+        add_definitions(-DFLTK1)
+      endif(NOT FLTK_VERSION OR FLTK_VERSION EQUAL 1.1)
+      set_config_option(HAVE_NATIVE_FILE_CHOOSER "NativeFileChooser")
+    endif(ENABLE_NATIVE_FILE_CHOOSER)
+    if(ENABLE_FL_TREE)
+      if(NOT FLTK_VERSION OR FLTK_VERSION EQUAL 1.1)
+        add_subdirectory(contrib/Fl_Tree)
+        include_directories(contrib/Fl_Tree)
+      endif(NOT FLTK_VERSION OR FLTK_VERSION EQUAL 1.1)
+      set_config_option(HAVE_FL_TREE "FlTree")
+    endif(ENABLE_FL_TREE)
+  endif(HAVE_FLTK)
+elseif(ENABLE_QT)
+  find_package(Qt4)
+  set(QT_USE_QTOPENGL TRUE)
+  include(${QT_USE_FILE})
+  if(QT_FOUND)
+    add_subdirectory(Qt)
+    set_config_option(HAVE_QT "Qt")
+    list(APPEND EXTERNAL_INCLUDES ${QT_INCLUDE_DIR})
+  endif(QT_FOUND)
+endif(ENABLE_FLTK)
 
 if(APPLE)
   set(glut "-framework GLUT")
 else(APPLE)
-  set(glut "glut")
+  list(APPEND EXTERNAL_LIBRARIES "glut")
 endif(APPLE)
 
+  if(ENABLE_MMG3D)
+    find_library(MMG3D_LIB mmg3dlib4.0 PATH_SUFFIXES lib)
+    find_path(MMG3D_INC "libmmg3d.h" PATH_SUFFIXES src include)
+    if(MMG3D_LIB AND MMG3D_INC)
+       list(APPEND EXTERNAL_LIBRARIES ${MMG3D_LIB})
+       list(APPEND EXTERNAL_INCLUDES ${MMG3D_INC})
+    else(MMG3D_LIB AND MMG3D_INC)
+       message(STATUS "System MMG3D not found - using contrib/mmg3d instead")
+       add_subdirectory(contrib/mmg3d)
+       include_directories(contrib/mmg3d/build/sources)
+    endif(MMG3D_LIB AND MMG3D_INC)
+    set_config_option(HAVE_MMG3D "Mmg3d")
+  endif(ENABLE_MMG3D)
+
+  if(ENABLE_TETGEN_NEW AND EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/contrib/TetgenNew/tetgen.h)
+    add_subdirectory(contrib/TetgenNew)
+    include_directories(contrib/TetgenNew)
+    set_config_option(HAVE_TETGEN "Tetgen(New)")
+    add_definitions(-DTETLIBRARY)
+    message("WARNING: You are including an experimental version of Tetgen "
+            "that is KNOWN TO BE BUGGY on 64 bits archs and on WIN32/MSVC.")
+  elseif(ENABLE_TETGEN AND EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/contrib/Tetgen/tetgen.h)
+    add_subdirectory(contrib/Tetgen)
+    include_directories(contrib/Tetgen)
+    set_config_option(HAVE_TETGEN "Tetgen")
+    add_definitions(-DTETLIBRARY)
+  elseif(ENABLE_TETGEN)
+    find_library(TETGEN_LIB tet PATH_SUFFIXES lib)
+    find_path(TETGEN_INC "tetgen.h" PATH_SUFFIXES src include tetgen)
+    if(TETGEN_LIB AND TETGEN_INC)
+      list(APPEND EXTERNAL_LIBRARIES ${TETGEN_LIB})
+      list(APPEND EXTERNAL_INCLUDES ${TETGEN_INC})
+      set_config_option(HAVE_TETGEN "Tetgen")
+    endif(TETGEN_LIB AND TETGEN_INC)
+  endif(ENABLE_TETGEN_NEW AND EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/contrib/TetgenNew/tetgen.h)
+  if(HAVE_TETGEN)
+    message("WARNING: By including Tetgen you have to comply with Tetgen's "
+            "special licensing requirements stated in contrib/Tetgen/LICENSE.")
+  endif(HAVE_TETGEN)
+
+if(ENABLE_MED OR ENABLE_CGNS)
+  find_library(HDF5_LIB hdf5)
+  if(HDF5_LIB)
+    if(ENABLE_MED)
+      find_library(MED_LIB med)
+      if(MED_LIB)
+        set_config_option(HAVE_MED "Med")
+        list(APPEND EXTERNAL_LIBRARIES ${MED_LIB})
+      endif(MED_LIB)
+    endif(ENABLE_MED)    
+    if(ENABLE_CGNS)
+      find_library(CGNS_LIB cgns PATHS ENV CGNS_ROOT PATH_SUFFIXES lib)
+      find_path(CGNS_INC "cgnslib.h" PATHS ENV CGNS_ROOT PATH_SUFFIXES include)
+      if(CGNS_LIB)
+        set_config_option(HAVE_LIBCGNS "Cgns")
+        list(APPEND EXTERNAL_LIBRARIES ${CGNS_LIB})
+        list(APPEND EXTERNAL_INCLUDES ${CGNS_INC})
+      endif(CGNS_LIB)
+    endif(ENABLE_CGNS)    
+    if(MED_LIB OR CGNS_LIB)
+      list(APPEND EXTERNAL_LIBRARIES ${HDF5_LIB})
+      find_library(SZ_LIB NAMES szlib sz)
+      if(SZ_LIB)
+        list(APPEND EXTERNAL_LIBRARIES ${SZ_LIB})
+      endif(SZ_LIB)
+      if(NOT HAVE_LIBZ) # necessary for non-GUI builds
+        find_package(ZLIB)
+        if(ZLIB_FOUND)
+          set_config_option(HAVE_LIBZ "Zlib")
+          list(APPEND EXTERNAL_LIBRARIES ${ZLIB_LIBRARIES})
+        endif(ZLIB_FOUND)
+      endif(NOT HAVE_LIBZ)
+    endif(MED_LIB OR CGNS_LIB)
+  endif(HDF5_LIB)
+endif(ENABLE_MED OR ENABLE_CGNS)
+
+if(ENABLE_MESH)
+  set_config_option(HAVE_MESH "Mesh")
+endif(ENABLE_MESH)
+
+if(ENABLE_POST)
+  set_config_option(HAVE_POST "Post")
+  if(ENABLE_PLUGINS)
+    set_config_option(HAVE_PLUGINS "Plugins")
+  endif(ENABLE_PLUGINS)
+endif(ENABLE_POST)
+
+if(HAVE_FLTK OR HAVE_QT OR ENABLE_GRAPHICS)
+  if(NOT HAVE_MESH OR NOT HAVE_POST OR NOT HAVE_PLUGINS)
+    message(SEND_ERROR "Cannot compile GUI without Mesh, Post or Plugin modules")
+  endif(NOT HAVE_MESH OR NOT HAVE_POST OR NOT HAVE_PLUGINS)
+
+  if(FLTK_JPEG)
+    set_config_option(HAVE_LIBJPEG "Jpeg(Fltk)")
+  else(FLTK_JPEG)
+    find_package(JPEG)
+    if(JPEG_FOUND)
+      set_config_option(HAVE_LIBJPEG "Jpeg")
+      list(APPEND EXTERNAL_LIBRARIES ${JPEG_LIBRARIES})
+      list(APPEND EXTERNAL_INCLUDES ${JPEG_INCLUDE_DIR})
+    endif(JPEG_FOUND)
+  endif(FLTK_JPEG)
+
+  if(FLTK_Z)
+    set_config_option(HAVE_LIBZ "Zlib(Fltk)")
+  else(FLTK_Z)
+    find_package(ZLIB)
+    if(ZLIB_FOUND)
+      set_config_option(HAVE_LIBZ "Zlib")
+      list(APPEND EXTERNAL_LIBRARIES ${ZLIB_LIBRARIES})
+      list(APPEND EXTERNAL_INCLUDES ${ZLIB_INCLUDE_DIR})
+    endif(ZLIB_FOUND)
+  endif(FLTK_Z)
+
+  if(HAVE_LIBZ)
+    if(FLTK_PNG)
+      set_config_option(HAVE_LIBPNG "Png(Fltk)")
+    else(FLTK_PNG)
+      find_package(PNG)
+      if(PNG_FOUND)
+        set_config_option(HAVE_LIBPNG "Png")
+        list(APPEND EXTERNAL_LIBRARIES ${PNG_LIBRARIES})
+        list(APPEND EXTERNAL_INCLUDES ${PNG_INCLUDE_DIR})
+      endif(PNG_FOUND)
+    endif(FLTK_PNG)
+  endif(HAVE_LIBZ)
+
+  if(ENABLE_MPEG_ENCODE)
+    add_subdirectory(contrib/mpeg_encode)
+    include_directories(contrib/mpeg_encode/headers)
+    set_config_option(HAVE_MPEG_ENCODE "Mpeg")
+  endif(ENABLE_MPEG_ENCODE)
+
+  if(ENABLE_OSMESA)
+    find_library(OSMESA_LIB OSMesa)
+    if(OSMESA_LIB)
+      set_config_option(HAVE_OSMESA "OSMesa")
+      list(APPEND EXTERNAL_LIBRARIES ${OSMESA_LIB})
+    endif(OSMESA_LIB)
+  endif(ENABLE_OSMESA)
+
+  find_package(OpenGL REQUIRED)
+  if(OPENGL_GLU_FOUND)
+    set_config_option(HAVE_OPENGL "OpenGL")
+  else(OPENGL_GLU_FOUND)
+    message(SEND_ERROR "Could not find GLU: disabling OpenGL support")
+  endif(OPENGL_GLU_FOUND)
+endif(HAVE_FLTK OR HAVE_QT OR ENABLE_GRAPHICS)
+
+if(ENABLE_DINTEGRATION)
+  include_directories(../contrib/DiscreteIntegration)
+  set_config_option(HAVE_DINTEGRATION "DIntegration")
+endif(ENABLE_DINTEGRATION)
+
+# process cmake environment variables so we can append them to the -I
+# include commands. This is not recommended (we should only use the
+# cache variables) but it is very convenient: otherwise we have to
+# remember providing the -D... options to cmake for each new build.
+set(ENV_CMAKE_PREFIX_PATH $ENV{CMAKE_PREFIX_PATH})
+set(ENV_CMAKE_INCLUDE_PATH $ENV{CMAKE_INCLUDE_PATH})
+if(UNIX)
+  if(ENV_CMAKE_PREFIX_PATH)
+    string(REPLACE ":" ";" ENV_CMAKE_PREFIX_PATH ${ENV_CMAKE_PREFIX_PATH})
+  endif(ENV_CMAKE_PREFIX_PATH)
+  if(ENV_CMAKE_INCLUDE_PATH)
+    string(REPLACE ":" ";" ENV_CMAKE_INCLUDE_PATH ${ENV_CMAKE_INCLUDE_PATH})
+  endif(ENV_CMAKE_INCLUDE_PATH)
+endif(UNIX)
+list(APPEND EXTERNAL_INCLUDES ${CMAKE_INCLUDE_PATH} ${ENV_CMAKE_INCLUDE_PATH})
+list(APPEND EXTERNAL_INCLUDES ${CMAKE_PREFIX_PATH} ${ENV_CMAKE_PREFIX_PATH})
+foreach(DIR ${CMAKE_PREFIX_PATH} ${ENV_CMAKE_PREFIX_PATH})
+  list(APPEND EXTERNAL_INCLUDES ${DIR}/include)
+endforeach(DIR)
+
+if(EXTERNAL_INCLUDES)
+  list(REMOVE_DUPLICATES EXTERNAL_INCLUDES)
+endif(EXTERNAL_INCLUDES)
+
+if(HAVE_FLTK)
+  set(LINK_LIBRARIES ${FLTK_LIBRARIES} ${EXTERNAL_LIBRARIES} 
+                     ${OPENGL_LIBRARIES} ${LAPACK_LIBRARIES})
+elseif(HAVE_QT)
+  set(LINK_LIBRARIES ${QT_LIBRARIES} ${EXTERNAL_LIBRARIES}
+                     ${OPENGL_LIBRARIES} ${LAPACK_LIBRARIES})
+elseif(HAVE_OPENGL)
+  set(LINK_LIBRARIES ${EXTERNAL_LIBRARIES} ${OPENGL_LIBRARIES}
+                     ${LAPACK_LIBRARIES})
+else(HAVE_FLTK)
+  set(LINK_LIBRARIES ${EXTERNAL_LIBRARIES} ${LAPACK_LIBRARIES})
+endif(HAVE_FLTK)
+
+# set this for external codes that might include this CMakeList file
+set(GMSH_EXTERNAL_INCLUDE_DIRS ${EXTERNAL_INCLUDES} CACHE 
+    STRING "External include directories" FORCE)
+set(GMSH_EXTERNAL_LIBRARIES ${EXTERNAL_LIBRARIES} CACHE 
+    STRING "External libraries" FORCE)
+
+include_directories(${GMSH_EXTERNAL_INCLUDE_DIRS})
+
 add_executable(mainAntTweakBar mainAntTweakBar.cpp)
-target_link_libraries(mainAntTweakBar shared AntTweakBar ${glut})
+target_link_libraries(mainAntTweakBar ${LINK_LIBRARIES})
 
 add_executable(mainCartesian mainCartesian.cpp)
-target_link_libraries(mainCartesian shared)
+target_link_libraries(mainCartesian ${LINK_LIBRARIES})
 
 add_executable(mainElasticity mainElasticity.cpp)
-target_link_libraries(mainElasticity shared)
+target_link_libraries(mainElasticity ${LINK_LIBRARIES})
 
 add_executable(mainGlut mainGlut.cpp)
-target_link_libraries(mainGlut lib ${GMSH_EXTERNAL_LIBRARIES} ${glut})
+target_link_libraries(mainGlut ${glut} ${LINK_LIBRARIES})
 
 add_executable(mainHomology mainHomology.cpp)
-target_link_libraries(mainHomology shared)
+target_link_libraries(mainHomology ${LINK_LIBRARIES})
 
 add_executable(mainLevelset mainLevelset.cpp)
-target_link_libraries(mainLevelset shared)
+target_link_libraries(mainLevelset ${LINK_LIBRARIES})
 
 add_executable(mainOcc mainOcc.cpp)
-target_link_libraries(mainOcc shared)
+target_link_libraries(mainOcc ${LINK_LIBRARIES})
 
 add_executable(mainPost mainPost.cpp)
-target_link_libraries(mainPost shared)
+target_link_libraries(mainPost ${LINK_LIBRARIES})
 
 add_executable(mainSimple mainSimple.cpp)
-target_link_libraries(mainSimple shared)
+target_link_libraries(mainSimple ${LINK_LIBRARIES})
 
--- a/utils/api_demos/mainAntTweakBar.cpp
+++ b/utils/api_demos/mainAntTweakBar.cpp
@@ -14,6 +14,7 @@
 #include "GModel.h"
 #include "MElement.h"
 #include "drawContext.h"
+#include <cstring>
 
 static drawContext *ctx = 0;
 static mousePosition clickPos, prevPos;
--- a/utils/api_demos/mainCartesian.cpp
+++ b/utils/api_demos/mainCartesian.cpp
@@ -12,7 +12,7 @@
 #include "GmshMessage.h"
 #include "cartesian.h"
 
-static void insertActiveCells(double x, double y, double z, double rmax,
+static void my_insertActiveCells(double x, double y, double z, double rmax,
                               cartesianBox<double> &box)
 {
   int id1 = box.getCellContainingPoint(x - rmax, y - rmax, z - rmax);
@@ -27,7 +27,7 @@
         box.insertActiveCell(box.getCellIndex(i, j, k));
 }
 
-static void computeLevelset(GModel *gm, cartesianBox<double> &box)
+static void my_computeLevelset(GModel *gm, cartesianBox<double> &box)
 {
   // tolerance for desambiguation
   const double tol = box.getLC() * 1.e-12;
@@ -82,10 +82,10 @@
   for (unsigned int j = 0; j < dist.size(); j++)
     box.setNodalValue(indices[j], dist[j]);
 
-  if(box.getChildBox()) computeLevelset(gm, *box.getChildBox());
+  if(box.getChildBox()) my_computeLevelset(gm, *box.getChildBox());
 }
 
-static void fillPointCloud(GEdge *ge, double sampling, std::vector<SPoint3> &points)
+static void my_fillPointCloud(GEdge *ge, double sampling, std::vector<SPoint3> &points)
 {
   Range<double> t_bounds = ge->parBounds(0);
   double t_min = t_bounds.low();
@@ -99,7 +99,7 @@
   }
 }
 
-static int removeBadChildCells(cartesianBox<double> *parent)
+static int my_removeBadChildCells(cartesianBox<double> *parent)
 {
   cartesianBox<double> *child = parent->getChildBox();
   if(!child) return 0;
@@ -135,10 +135,10 @@
             (k != K - 1 && !parent->activeCellExists(parent->getCellIndex(i, j, k + 1)))))
             for(int ii = 0; ii < 8; ii++) child->eraseActiveCell(idx[ii]);
       }
-  return removeBadChildCells(child);
+  return my_removeBadChildCells(child);
 }
 
-static void removeParentCellsWithChildren(cartesianBox<double> *box)
+static void my_removeParentCellsWithChildren(cartesianBox<double> *box)
 {
   if(!box->getChildBox()) return;
   for(int i = 0; i < box->getNxi(); i++)
@@ -157,7 +157,7 @@
           }
         }
       }
-  removeParentCellsWithChildren(box->getChildBox());
+  my_removeParentCellsWithChildren(box->getChildBox());
 }
 
 static void removeOutsideCells(cartesianBox<double> *box)
@@ -226,7 +226,7 @@
     double s = sampling / pow(2., levels - 1);
     Msg::Info("Filling refined point cloud on curves and curved surfaces");
     for (GModel::eiter eit = gm->firstEdge(); eit != gm->lastEdge(); eit++)
-      fillPointCloud(*eit, s, refinePoints);
+      my_fillPointCloud(*eit, s, refinePoints);
 
     // FIXME: refine this by computing e.g. "mean" curvature
     if(refineCurvedSurfaces){
@@ -263,13 +263,13 @@
   Msg::Info("Inserting active cells in the cartesian grid");
   Msg::Info("  level %d", box.getLevel());
   for (unsigned int i = 0; i < points.size(); i++)
-    insertActiveCells(points[i].x(), points[i].y(), points[i].z(), rmax, box);
+    my_insertActiveCells(points[i].x(), points[i].y(), points[i].z(), rmax, box);
 
   cartesianBox<double> *parent = &box, *child;
   while((child = parent->getChildBox())){
     Msg::Info("  level %d", child->getLevel());
     for(unsigned int i = 0; i < refinePoints.size(); i++)
-      insertActiveCells(refinePoints[i].x(), refinePoints[i].y(), refinePoints[i].z(),
+      my_insertActiveCells(refinePoints[i].x(), refinePoints[i].y(), refinePoints[i].z(),
                         rtube / pow(2., (levels - child->getLevel())), *child);
     parent = child;
   }
@@ -278,8 +278,8 @@
   // which there is no parent neighbor; then remove parent cells that
   // have children
   Msg::Info("Removing cells to match X-FEM mesh topology constraints");
-  removeBadChildCells(&box);
-  removeParentCellsWithChildren(&box);
+  my_removeBadChildCells(&box);
+  my_removeParentCellsWithChildren(&box);
 
   // we generate duplicate nodes at this point so we can easily access
   // cell values at each level; we will clean up by renumbering after
@@ -288,7 +288,7 @@
   box.createNodalValues();
 
   Msg::Info("Computing levelset on the cartesian grid");
-  computeLevelset(gm, box);
+  my_computeLevelset(gm, box);
 
   Msg::Info("Removing cells outside the structure");
   removeOutsideCells(&box);
--- a/utils/api_demos/mainElasticity.cpp
+++ b/utils/api_demos/mainElasticity.cpp
@@ -3,6 +3,7 @@
 #include "elasticitySolver.h"
 #include "PView.h"
 #include "PViewData.h"
+#include <cstring>
 
 void Info (int i, char* c){
   printf("%d %s\n",i,c);
